\documentclass[a4paper,12pt]{report}

\usepackage{amsmath,amsfonts,mathtools}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}
\title{ECE253 Abridged}
\author{Aman Bhargava}
\date{September 2019}
\maketitle

\tableofcontents

\pagebreak

\chapter{Review: Bit Manipulation}
Have you ever wanted to be a cool computer person who does things with ones and zero's instead of actual letters and numbers like a normal person? If so, this is the right chapter for you!

\section{Converting to and from Different Bases}
Base 10, 2, and 16 are most commonly used. Base 16 is just a way to read base 2 in a more efficient manner. In order to work with bits it's pretty important to know how to convert back and forth because the test is all on paper. 

\subsection{Converting from base 10 $\to$ base 2}
You keep dividing by two, keeping track of the remainder. Eventually the number you will be trying to divide by two will be 1. You keep going until it's zero + remainder(1). Then you read the reaminders upward from that final 1.

\subsection{Converting from base 2 $\to$ base 16}
Any hex number can be expressed as 4 binary digits. Make a correspondence table between quadruplets of binary numbers and hex (1-f, inclusive). To convert to base 16 subdivide from right to left in groups of four binary digits. Pad the leftmost part with leading zeros and convert using the table. 

\subsection{Converting from base 10 $\to$ base 16 (and vice versa)}
Just go through base 2 fam.

\chapter{Logic Functions and Logic Gates}
\section{Or Gate}
\begin{enumerate}
\item Symbols
\item Switch structure
\item Truth table
\end{enumerate}

\section{And Gate}

\section{Inverter}

\section{XOR}


\chapter{Boolean Algebra}
Here are the axioms of Boolean Algebra:
\begin{enumerate}
\item $0 \cdot 0 = 0$
\item $1 \cdot 1 = 1$
\item $0 \cdot 1 = 1 \cdot 0 = 0$
\item if $x = 0$, $!x = 1$
\end{enumerate}

\paragraph{Dual Form}
\begin{enumerate}
\item $1 + 1 = 1$
\item $0 + 0 = 0$
\item $1 + 0 = 0 + 1 = 1$
\item if $x = 1$, $!x = 0$
\end{enumerate}

\paragraph{Duality: } In a given logic expression, you can swap $1 \to 0$ and $\cdot \to +$
and the expression is still valid.

\section{Useful Boolean Expression Rules}
\begin{itemize}
\item $x \cdot 0 = 0$
\item $x \cdot 1 = x$
\item $x \cdot x = x$
\item $x \cdot !x = 0$
\item $x \cdot 0 = 0$
\item $!!x = x$
\item $x + 1 = 1$
\item $x + 0 = x$
\item $x + x = x$
\item $x + !x = 1$
\end{itemize}

\paragraph{Distributive Properties: }
$$x \cdot (y + z) = xy + xz$$
$$x + (y \cdot z) = (x+y) \cdot (x+z)$$

% \section{Less Obvious Identities}
% \begin{itemize}
% \item 
% \end{itemize}


\section{Sum-of-Products (SOP)}
'Sum' means boolean OR while 'product' means boolean AND. 

\paragraph{Min term: } for $n$ variables, term where all variables appear once is a 'minterm'.
Note that variables can either be complimented or uncomplimented. 

Any boolean function can be represented by the sum of products of minterms - this is just done 
by simply converting the truth table and OR-ing each truth. 

Then, you can simplify. Pretty common sense. 'Canonical' just means it's a bunch of midterms
separated by OR's.

\section{Product of Sums (POS)}
\paragraph{Max term: } where all $n$ variables appear OR-d. They can be complimented or
un-complimented. 

You can pretty easily make all the valid max terms from a truth table. To generate a POS
expression, you multiply (AND) the maxterms that sum to zero. 

\section{NAND and NOR Logic Networks (TB 2.7)}


\section{Three-Way Light Control (TB 2.8.1)}


\chapter{How 2 Verilog}
A 3-input multiplexer can be made with two 2-input multiplexers.
Now let's implement this without using two pre-made multiplexers. Let:
\begin{itemize}
\item 
\end{itemize}

\paragraph{Notes on Implementation}
\begin{itemize}
\item If you want inputs to be registered from switches, you need to assign them SW[<int>]
\item Likewise, if you want outputs to be registered to LED's, assign them LEDR[<int>]
\end{itemize}

\subsection{Code: 3-Way Multiplexer}

\lstset{frame=tb,
  language=Verilog,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{lstlisting}
module mux2b2to1 (SW, LEDR); //Two bit 2 to 1 multiplexer  
   input[4:0] SW, //[4:0] sets switches 0-4 to inputs(?)
   output[1:0] LEDR, //

   wire S;
   wire[1:0] a, b, z; //'two bit wide vector'?

   assign a = SW[1:0],
   assign b = SW[3:2],
   assign s = SW[4],
   assign LEDR = z,

   assign z[0] = (~s&a[0]) | (s&b[0]);
   assign z[1] = (~s & a[1]) | (s&b[1]);

endmodule;
\end{lstlisting}

\paragraph{Can you make the assignment more efficient?}
What if you do this:
\begin{lstlisting}
   // assign z[0] = (~s&a[0]) | (s&b[0]);
   // assign z[1] = (~s & a[1]) | (s&b[1]);
   assign z = (~s&a) | (s&b); // NOT CORRECT
\end{lstlisting}

\paragraph{Because $s$ is only 1-bit and $a, b$ are two bits, $s$ is extended with a \textbf{0}, 
which makes the logic incorrect!}

\paragraph{General Notes on how Syntax Works:}
\begin{itemize}
\item \textbf{What is 'assign'? } 'assign' just means you're making a connection (alias?) b/w the
two. \textbf{Question: } is this necessary for instantiating the variable?
\item \textbf{Assignment arith.} When you create a verilog wire/input with $x = [a:b]$, the number of bits in 
$x$ is $b-a + 1$
\item \textbf{Bit Access: } To access bits, you say $x[n]$ or $x[n:m]$ where $n < m$. The length of the slice
is $n-m +1$
\item \textbf{Concatenation: } If you want to stitch together multiple bits, you use $x = {SW[9:8], SW[1:0]}$. That
statement stitches together two 2-bit chunks ($SW[9:8], SW[1:0]$ to make one 4-bit chunk).
\item \textbf{Order of Operations: } Basically nobody knows... just use parenthesis when you're
not sure. And goes before or, though.
\end{itemize}


\section{Full Adder}
\paragraph{Description: }
Adding in binary is the same as in decimal, just with fewer options. When adding two single bits,
we have three output possibilities: $00, 01, 10$. We call the least significant bit the sum $s$ and
the most significant digit the carry $c$.

Let's see the truth table:
\begin{tabular}{ll|ll}
$x$ & $y$ & $C$ & $s$ \\
\hline
0 & 0 & 0 & 0 \\
0 & 1 & 0 & 1 \\
1 & 0 & 0 & 1 \\
1 & 1 & 1 & 0 \\
\end{tabular}

As you can see, the sum bit is just $x \oplus y$ and the carry bit is $xy$. 
This is a \textbf{half adder} because it doesn't accept a carry from the last calculation.

A full adder accepts a carry in $C_{in}$, $x$, and $y$, and outputs sum $s$ and carry out $C_{out}$.

Let's see the truth table:
\begin{tabular}{lll|ll}
$x$ & $y$ & $C_{in}$ & $C_{out}$ & $s$ \\
\hline
0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 \\
0 & 1 & 1 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 \\
1 & 0 & 1 & 1 & 0 \\
1 & 1 & 0 & 1 & 0 \\
1 & 1 & 1 & 1 & 1 \\
\end{tabular}

Therefore $$C_{out} = xy + xC_{in} + yC_{in}$$
and $$s = x \oplus y \oplus C_{in}$$

\paragraph{Ripple Carry Adder: } Then you can string them together by assigning one of these 
adders to each bit of the output and passing the carry out to the carry in of the next bit!

\paragraph{Specifics for Ripple Carry Adder: }
\begin{itemize}
\item Max size for output is one more then the two input's sizes because one more order of 
magnitude in binary is just doubling the number, and the most you can do when adding two 
numbers of equal length is double them.
\item Basically just string them together and you're golden.
\end{itemize}

\paragraph{Review of Outcomes}
\begin{itemize}
\item $Cout = xy + CinX + CinY$
\item $Sum = x \oplus y \oplus z$
\end{itemize}

\paragraph{Now let's make it in verilog!}
\begin{lstlisting}
module fulladder(x, y, Cin, S, Cout);
   input x, y, Cin;
   output S, Cout;

   assign s = x ^ y ^ Cin;
   assign Cout = (x&y) | (Cin&x) | (Cin&y); // Why no wires here? Bc no physical IO's.
\end{lstlisting}

\paragraph{Now we make a 3-bit adder out of full adders in Verilog!}
\begin{lstlisting}
module adder3bit(X, Y, S)
   input[2:0] X, Y;
   output[3:0] S;
   wire[3:0] C; // to connect full adders together

   fulladder U0(X[0], Y[0], C[0], C[1]);
   fulladder U1(X[1], Y[1], C[1], C[2]);
   fulladder U2(X[2], Y[2], C[2], C[3]);

   assign S[3] = C[3]; // Final carry bit is the most significant bit of the sum.
   assign C[0] = 1'b0; // Weird syntax: 1 bit, equal to 0.
endmodule;
\end{lstlisting}

This is structural verilog - we can't immediately see the bigger picture. We see wires and 
modules stitched together and we have to figure out what it all means.

\paragraph{Weird constant syntax: }
\begin{itemize}
\item $1'b0$: 1 bit constant, in binary, equal to 0.
\item $4'hF$: 4 bit constant, in hex, equal to F.
\item $4'd9$: 4 bit constant, in decimal, equal to 9.
\item $8'h1E$: 8 bit constant, in hex, equal to 1E.
\end{itemize}

\section{7-Segment Display}
\paragraph{Prompt: } Design a c ircuit with two inputs $x_1$ and $x_0$ representing a 
2-bit number $x$. Show $x$ on the 7-segment display (ranges from 0-3 inclusive).

\paragraph{Numbering: } $h_0$ is the top segment. Clockwise increases. $h_6$ is the middle one.

\paragraph{Note on D1-SoC Board: } Logic 0 makes the light turn on for $h_{0-6}$ and 1 makes 
it turn off ('active low')

\subsection{Displaying Numbers}
Sections to light up for 0: $h_{0-5}$
Sections to light up for 1: $h_{1-2}$
Sections to light up for 2: $h_{0-1}, h_6, h_{3-4}$
Sections to light up for 3: $h_{0-3}, h_6$

\paragraph{With active low: }
Sections to power for 0: $h_{6}$
Sections to power for 1: $h_{0}, h_{3-6}$
Sections to power for 2: $.$
Sections to power for 3: 

\paragraph{Truth Table: }
\begin{tabular}{ll|lllllll}
$x_1$ & $x_2$ & $h_6$ & $h_5$ & $h_4$ & $h_3$ & $h_2$ & $h_1$ & $h_0$  \\
\hline
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 1  \\
1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0  \\
1 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0  \\
\end{tabular}

\paragraph{Consolidating the Logic Functions: }
$$h_0 = (!x_1) \cdot x_0$$
$$h_1 = 0$$
$$h_2 = x_1 \cdot !x_0$$
$$h_3 = !x_1 \cdot x_0$$
$$h_4 = x_0$$
$$h_5 = x_1 | x_0$$
$$h_6 = !x_1$$

\paragraph{Verilog Code: }
\begin{lstlisting}
module seg7(SW, HEX0)
   input[1:0] X;
   output[6:0] HEX0;
   
   assign HEX0[0] = ~SW[1] & SW[0];
   // etc.

endmodule
\end{lstlisting}

\paragraph{Implementation Example: }
Designa  circuit with 4 inputs $a, b, c, d$ and $s$. 
   if s = 0, show $a+b$ on 7-seg display
   if s = 1, show $c+d$ on 7-seg display

$${a, b} \to mux_{2 bit * 2 inputs} \to fulladd_{cin = 0} \to HEXO \to output$$

\begin{itemize}
\item The carry in digit to the full adder is 0
\item The carry out from the full adder is the most significant digit of the HEXO input.
\item Honestly you could just use a half adder because you don't need a carry-in. 
$C_{out} = xy$, $Sum = x \oplus y$
\end{itemize}

\paragraph{Cool XOR Fact: } $\oplus$ returns 1 if the number of true inputs is ODD.

\section{FPGA's}
Can do anything.
\begin{itemize}
\item Field programmable gate arrays: Programmable in the field (i.e. not in the factory necessarily).
\item 2-D array of programmable blocks.
\item Blocks contain lookup tables (LUT)
\item Any two input LUT can be programmed for any two-input logic functions.
\item More complex logic comes out when you connect the LUTS - this is what Quartus does.
\end{itemize}

\paragraph{How to encode any two-input thing}
Let there be 4 sRAM bits $p, q, r, s$. Let the inputs be $a, b$. 

$${p, q} \to mux_{a1} \to x$$
$${r, s} \to mux_{a1} \to y$$
Where $x, y$ are itermediate variables.

$${x, y} \to mux_{b} \to output$$

Therefore it takes 4 ram cells for a 2-input LUT. $$n_{ramcells} = 2^{inputs}$$

There are 85,000 6-LUTS on lab chips.

\end{document}
