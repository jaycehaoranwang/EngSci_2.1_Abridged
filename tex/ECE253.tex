\documentclass[a4paper,12pt]{report}

\usepackage{amsmath,amsfonts,mathtools}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}
\title{ECE253 Abridged}
\author{Aman Bhargava}
\date{September 2019}
\maketitle

\tableofcontents

\pagebreak

\chapter{Review: Bit Manipulation}
Have you ever wanted to be a cool computer person who does things with ones and zero's instead of actual letters and numbers like a normal person? If so, this is the right chapter for you!

\section{Converting to and from Different Bases}
Base 10, 2, and 16 are most commonly used. Base 16 is just a way to read base 2 in a more efficient manner. In order to work with bits it's pretty important to know how to convert back and forth because the test is all on paper. 

\subsection{Converting from base 10 $\to$ base 2}
You keep dividing by two, keeping track of the remainder. Eventually the number you will be trying to divide by two will be 1. You keep going until it's zero + remainder(1). Then you read the reaminders upward from that final 1.

\subsection{Converting from base 2 $\to$ base 16}
Any hex number can be expressed as 4 binary digits. Make a correspondence table between quadruplets of binary numbers and hex (1-f, inclusive). To convert to base 16 subdivide from right to left in groups of four binary digits. Pad the leftmost part with leading zeros and convert using the table. 

\subsection{Converting from base 10 $\to$ base 16 (and vice versa)}
Just go through base 2 fam.

\chapter{Logic Functions and Logic Gates}
\section{Or Gate}
\begin{enumerate}
\item Symbols
\item Switch structure
\item Truth table
\end{enumerate}

\section{And Gate}

\section{Inverter}

\section{XOR}


\chapter{Boolean Algebra}
Here are the axioms of Boolean Algebra:
\begin{enumerate}
\item $0 \cdot 0 = 0$
\item $1 \cdot 1 = 1$
\item $0 \cdot 1 = 1 \cdot 0 = 0$
\item if $x = 0$, $!x = 1$
\end{enumerate}

\paragraph{Dual Form}
\begin{enumerate}
\item $1 + 1 = 1$
\item $0 + 0 = 0$
\item $1 + 0 = 0 + 1 = 1$
\item if $x = 1$, $!x = 0$
\end{enumerate}

\paragraph{Duality: } In a given logic expression, you can swap $1 \to 0$ and $\cdot \to +$
and the expression is still valid.

\section{Useful Boolean Expression Rules}
\begin{itemize}
\item $x \cdot 0 = 0$
\item $x \cdot 1 = x$
\item $x \cdot x = x$
\item $x \cdot !x = 0$
\item $x \cdot 0 = 0$
\item $!!x = x$
\item $x + 1 = 1$
\item $x + 0 = x$
\item $x + x = x$
\item $x + !x = 1$
\end{itemize}

\paragraph{Distributive Properties: }
$$x \cdot (y + z) = xy + xz$$
$$x + (y \cdot z) = (x+y) \cdot (x+z)$$

% \section{Less Obvious Identities}
% \begin{itemize}
% \item 
% \end{itemize}


\section{Sum-of-Products (SOP)}
'Sum' means boolean OR while 'product' means boolean AND. 

\paragraph{Min term: } for $n$ variables, term where all variables appear once is a 'minterm'.
Note that variables can either be complimented or uncomplimented. 

Any boolean function can be represented by the sum of products of minterms - this is just done 
by simply converting the truth table and OR-ing each truth. 

Then, you can simplify. Pretty common sense. 'Canonical' just means it's a bunch of midterms
separated by OR's.

\section{Product of Sums (POS)}
\paragraph{Max term: } where all $n$ variables appear OR-d. They can be complimented or
un-complimented. 

You can pretty easily make all the valid max terms from a truth table. To generate a POS
expression, you multiply (AND) the maxterms that sum to zero. 

\section{NAND and NOR Logic Networks (TB 2.7)}


\section{Three-Way Light Control (TB 2.8.1)}


\chapter{How 2 Verilog}
A 3-input multiplexer can be made with two 2-input multiplexers.
Now let's implement this without using two pre-made multiplexers. Let:
\begin{itemize}
\item 
\end{itemize}

\paragraph{Notes on Implementation}
\begin{itemize}
\item If you want inputs to be registered from switches, you need to assign them SW[<int>]
\item Likewise, if you want outputs to be registered to LED's, assign them LEDR[<int>]
\end{itemize}

\subsection{Code: 3-Way Multiplexer}

\lstset{frame=tb,
  language=Verilog,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{lstlisting}
module mux2b2to1 (SW, LEDR); //Two bit 2 to 1 multiplexer  
   input[4:0] SW, //[4:0] sets switches 0-4 to inputs(?)
   output[1:0] LEDR, //

   wire S;
   wire[1:0] a, b, z; //'two bit wide vector'?

   assign a = SW[1:0],
   assign b = SW[3:2],
   assign s = SW[4],
   assign LEDR = z,

   assign z[0] = (~s&a[0]) | (s&b[0]);
   assign z[1] = (~s & a[1]) | (s&b[1]);

endmodule;
\end{lstlisting}

\paragraph{Can you make the assignment more efficient?}
What if you do this:
\begin{lstlisting}
   // assign z[0] = (~s&a[0]) | (s&b[0]);
   // assign z[1] = (~s & a[1]) | (s&b[1]);
   assign z = (~s&a) | (s&b); // NOT CORRECT
\end{lstlisting}

\paragraph{Because $s$ is only 1-bit and $a, b$ are two bits, $s$ is extended with a \textbf{0}, 
which makes the logic incorrect!}

\paragraph{General Notes on how Syntax Works:}
\begin{itemize}
\item \textbf{What is 'assign'? } 'assign' just means you're making a connection (alias?) b/w the
two. \textbf{Question: } is this necessary for instantiating the variable?
\item \textbf{Assignment arith.} When you create a verilog wire/input with $x = [a:b]$, the number of bits in 
$x$ is $b-a + 1$
\item \textbf{Bit Access: } To access bits, you say $x[n]$ or $x[n:m]$ where $n < m$. The length of the slice
is $n-m +1$
\item \textbf{Concatenation: } If you want to stitch together multiple bits, you use $x = {SW[9:8], SW[1:0]}$. That
statement stitches together two 2-bit chunks ($SW[9:8], SW[1:0]$ to make one 4-bit chunk).
\item \textbf{Order of Operations: } Basically nobody knows... just use parenthesis when you're
not sure. And goes before or, though.
\end{itemize}


\section{Full Adder}
\paragraph{Description: }
Adding in binary is the same as in decimal, just with fewer options. When adding two single bits,
we have three output possibilities: $00, 01, 10$. We call the least significant bit the sum $s$ and
the most significant digit the carry $c$.

Let's see the truth table:
\begin{tabular}{ll|ll}
$x$ & $y$ & $C$ & $s$ \\
\hline
0 & 0 & 0 & 0 \\
0 & 1 & 0 & 1 \\
1 & 0 & 0 & 1 \\
1 & 1 & 1 & 0 \\
\end{tabular}

As you can see, the sum bit is just $x \oplus y$ and the carry bit is $xy$. 
This is a \textbf{half adder} because it doesn't accept a carry from the last calculation.

A full adder accepts a carry in $C_{in}$, $x$, and $y$, and outputs sum $s$ and carry out $C_{out}$.

Let's see the truth table:
\begin{tabular}{lll|ll}
$x$ & $y$ & $C_{in}$ & $C_{out}$ & $s$ \\
\hline
0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 \\
0 & 1 & 1 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 \\
1 & 0 & 1 & 1 & 0 \\
1 & 1 & 0 & 1 & 0 \\
1 & 1 & 1 & 1 & 1 \\
\end{tabular}

Therefore $$C_{out} = xy + xC_{in} + yC_{in}$$
and $$s = x \oplus y \oplus C_{in}$$

\paragraph{Ripple Carry Adder: } Then you can string them together by assigning one of these 
adders to each bit of the output and passing the carry out to the carry in of the next bit!

\paragraph{Specifics for Ripple Carry Adder: }
\begin{itemize}
\item Max size for output is one more then the two input's sizes because one more order of 
magnitude in binary is just doubling the number, and the most you can do when adding two 
numbers of equal length is double them.
\item Basically just string them together and you're golden.
\end{itemize}

\paragraph{Review of Outcomes}
\begin{itemize}
\item $Cout = xy + CinX + CinY$
\item $Sum = x \oplus y \oplus z$
\end{itemize}

\paragraph{Now let's make it in verilog!}
\begin{lstlisting}
module fulladder(x, y, Cin, S, Cout);
   input x, y, Cin;
   output S, Cout;

   assign s = x ^ y ^ Cin;
   assign Cout = (x&y) | (Cin&x) | (Cin&y); // Why no wires here? Bc no physical IO's.
\end{lstlisting}

\paragraph{Now we make a 3-bit adder out of full adders in Verilog!}
\begin{lstlisting}
module adder3bit(X, Y, S)
   input[2:0] X, Y;
   output[3:0] S;
   wire[3:0] C; // to connect full adders together

   fulladder U0(X[0], Y[0], C[0], C[1]);
   fulladder U1(X[1], Y[1], C[1], C[2]);
   fulladder U2(X[2], Y[2], C[2], C[3]);

   assign S[3] = C[3]; // Final carry bit is the most significant bit of the sum.
   assign C[0] = 1'b0; // Weird syntax: 1 bit, equal to 0.
endmodule;
\end{lstlisting}

This is structural verilog - we can't immediately see the bigger picture. We see wires and 
modules stitched together and we have to figure out what it all means.

\paragraph{Weird constant syntax: }
\begin{itemize}
\item $1'b0$: 1 bit constant, in binary, equal to 0.
\item $4'hF$: 4 bit constant, in hex, equal to F.
\item $4'd9$: 4 bit constant, in decimal, equal to 9.
\item $8'h1E$: 8 bit constant, in hex, equal to 1E.
\end{itemize}

\section{7-Segment Display}
\paragraph{Prompt: } Design a c ircuit with two inputs $x_1$ and $x_0$ representing a 
2-bit number $x$. Show $x$ on the 7-segment display (ranges from 0-3 inclusive).

\paragraph{Numbering: } $h_0$ is the top segment. Clockwise increases. $h_6$ is the middle one.

\paragraph{Note on D1-SoC Board: } Logic 0 makes the light turn on for $h_{0-6}$ and 1 makes 
it turn off ('active low')

\subsection{Displaying Numbers}
Sections to light up for 0: $h_{0-5}$
Sections to light up for 1: $h_{1-2}$
Sections to light up for 2: $h_{0-1}, h_6, h_{3-4}$
Sections to light up for 3: $h_{0-3}, h_6$

\paragraph{With active low: }
Sections to power for 0: $h_{6}$
Sections to power for 1: $h_{0}, h_{3-6}$
Sections to power for 2: $.$
Sections to power for 3: 

\paragraph{Truth Table: }
\begin{tabular}{ll|lllllll}
$x_1$ & $x_2$ & $h_6$ & $h_5$ & $h_4$ & $h_3$ & $h_2$ & $h_1$ & $h_0$  \\
\hline
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0  \\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 1  \\
1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0  \\
1 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0  \\
\end{tabular}

\paragraph{Consolidating the Logic Functions: }
$$h_0 = (!x_1) \cdot x_0$$
$$h_1 = 0$$
$$h_2 = x_1 \cdot !x_0$$
$$h_3 = !x_1 \cdot x_0$$
$$h_4 = x_0$$
$$h_5 = x_1 | x_0$$
$$h_6 = !x_1$$

\paragraph{Verilog Code: }
\begin{lstlisting}
module seg7(SW, HEX0)
   input[1:0] X;
   output[6:0] HEX0;
   
   assign HEX0[0] = ~SW[1] & SW[0];
   // etc.

endmodule
\end{lstlisting}

\paragraph{Implementation Example: }
Designa  circuit with 4 inputs $a, b, c, d$ and $s$. 
   if s = 0, show $a+b$ on 7-seg display
   if s = 1, show $c+d$ on 7-seg display

$${a, b} \to mux_{2 bit * 2 inputs} \to fulladd_{cin = 0} \to HEXO \to output$$

\begin{itemize}
\item The carry in digit to the full adder is 0
\item The carry out from the full adder is the most significant digit of the HEXO input.
\item Honestly you could just use a half adder because you don't need a carry-in. 
$C_{out} = xy$, $Sum = x \oplus y$
\end{itemize}

\paragraph{Cool XOR Fact: } $\oplus$ returns 1 if the number of true inputs is ODD.

\section{FPGA's}
Can do anything.
\begin{itemize}
\item Field programmable gate arrays: Programmable in the field (i.e. not in the factory necessarily).
\item 2-D array of programmable blocks.
\item Blocks contain lookup tables (LUT)
\item Any two input LUT can be programmed for any two-input logic functions.
\item More complex logic comes out when you connect the LUTS - this is what Quartus does. 
\end{itemize}

\paragraph{How to encode any two-input thing}
Let there be 4 sRAM bits $p, q, r, s$. Let the inputs be $a, b$. 

$${p, q} \to mux_{a1} \to x$$
$${r, s} \to mux_{a1} \to y$$
Where $x, y$ are itermediate variables.

$${x, y} \to mux_{b} \to output$$

Therefore it takes 4 ram cells for a 2-input LUT. $$n_{ramcells} = 2^{inputs}$$

There are 85,000 6-LUTS on lab chips.

\chapter{Karnaugh Maps}
\section{Motivation}
Creating boolean functions to get what you need done is confusing and unlikely to lead to an optimal solution 
when there are many variables.

Karnaugh maps are a tool for expressing your truth tables in such a way that makes getting optimal solutions easier
with many variables.

\paragraph{Example 2x2 Karnaugh Map}
\begin{tabular}{l|cc}
& $0$ & $1$ \\
\hline
0 & a & b \\
1 & c & d \\
\end{tabular}


\section{Review of Terminology}

\begin{itemize}
\item \textbf{Implicant:} Any product term for which the function is true (think 'implies' logic is 1)
\item \textbf{Cover:} A set of implicants that covers all 1's of the function.
\item \textbf{Prime implicant:} Any implicant that, if we delete a literal, is no longer an implicant (largest
   groups of ones in the K-map)
\item \textbf{Essential prime implicant:} Prime implicant that covers a 1 covered by no other prime implicant.
\item \textbf{Min-cost cover:}
\item \textbf{Cost:}
\end{itemize}

\paragraph{Example: }
\begin{tabular}{l|cccc}
& $00$ & $01$ & $11$ & $10$   \\
\hline
0 & 1 & 1 & 1 & 1 \\
1 & 1 & 0 & 0 & 0 \\
\end{tabular}

Let the left column be the $z$ column and the top be products of $x, y$. 

List of implicants:
\begin{enumerate}
\item $\bar{z}$ 
\item $\bar{x} \bar{y}$
\item $\bar{x} \bar{z}$
\item $y\bar{z}$
\item $x\bar{z}$
\item $\bar{y}\bar{z}$
\item $m_{0, 1, 2, 4, 5}$
\end{enumerate}

Prime Implicants: Largest group of ones in cardinal maps...

\paragraph{Cost Defininition: } $n_{gates} + n_{inputs}$

\section{Procedure for Minimum Cost Cover}
\begin{itemize}
\item Find essential prime implicants and include in cover
\item Select additional prime implicants to include in the cover until all 1's are covered.
\end{itemize}

\section{5 Variable Karnaugh Map}
Use two 4-variable K-Maps. One for case where $x_5 = 0$, other for $x_5 = 1$.
Min-term indexing goes by the binary representation of $x_{0-n}$ where $x_n$ is the LEAST significant bit.


\chapter{Storage Elements}
\section{Introduction}
Until now, the values coming in have dependend on the state (high or low) of the input 
wires to the circuit. There's another option where the inputs dependent on past states 
of the circuit.

\paragraph{Storage elements } represent a \textbf{state} of a circuit. When inputs 
change, new inputs either leave circuit in the same state or change the state. These 
circuits are called \textbf{sequential} circuits. Memory elements can be created 
with logic gates. 

\section{RS Latches}
\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{../media/basicLatch.png}
\caption{Basic Latch}
\label{latch-basic}
\end{figure}
\subsection{Behavior} 
You use $S$ to set the output $Q_a$ to $1$ and $R$ to set $Q_a$ to $0$.

\begin{tabular}{ll|ll}
$S$ & $R$ & $Q_a$ & $Q_b$ \\
\hline
0 & 0 & No change &  \\
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0 \\
1 & 1 & 0 & 0 \\
\end{tabular}

$S$ functions as the 'set' signal. 


\section{Gated RS Latch}
Add an and gate to the inputs so that you can only enter signals to the latch when 
the $clk$ signal is $1$.

\subsection{Synchronous Reset}
This is when you can only use the reset when the clock is at 1 (basically you just 
AND the $D$ and the $R_n$ for an `active low' reset). Reset behavior is synchronized to the rising edge. 

\subsection{Behavior} 
Same as an RS latch, but you can only send $R$ and $S$ signals when the $clk$ is logic $1$.

\section{Gated D Latch}
Also called `Transparent Latch' or `Level-Sensitive Latch'. 

\subsection{Behavior: } When the clock is $1$, then $Q = D$. $Q$ changes as $D$ changes 
and then when the clock is turned back to $0$, then $Q$ persists in it's last state. 

\section{D Flip-Flops}
\paragraph{Symbol: } Same as the D Latch, but there's a triangle instead of $clk$. If 
it's a \textbf{negative edge} triggered flip-flop, the symbol has a bubble next to the 
clock. \textbf{Positive edge} appears to be the default. 

\paragraph{Edge-Triggered Flip Flop: } The flip flop only changes when the clock is 
on a rising edge or a falling edge. 

\subsection{Master-Slave Flip Flop}
You connect a master D-Latch to a slave D-Latch. The clock signals of one is the inverse 
of the clock symbol going into the other one. 

This setup yields a system where you can only change the value of $Q$ for the slave ($Q_s$) 
on a rising/falling edge. 

\subsection{Behavior} On rising or falling clock edge, the value of $D$ is stored and 
appears in $Q$.

\paragraph{Work-Through demonstration: } Let's say you have the inverted clock going 
to the slave. When you're in logic 1 for the clock, the master is in \textbf{transparent} 
mode. $Q_m = D$. When you switch, the value of the master is stuck and the value of the 
slave is set to $Q_m$. You can't reset the slave value after the transition because the 
\textbf{opaque} mode of the master. 

Pretty cool property! 

\subsection{Why it's Useful}

You can put these in the middle of circuits to save values. Then, you can re-inject inputs 
while you wait for the last half of the circuit to finish processing. It's like splitting 
the circuit into two pieces that can run on different elements simultaneously. 

This is a bit of a dumb way to think about it, but that's the general idea behind how 
they are actually used. 


\section{T Flip-Flop}
Let's take a D Flip Flop component and loop the value of $Q$ and $\bar{Q}$ back to the 
input $D$. Let's make $T$ the new input. $T$ switches the input of $D$ between $Q$ and 
$\bar{Q}$. 

\section{Flip-Flop Reset/Preset}

\section{Summary of Objects}

\section{Verilog Implementations}
\subsection{Gated D-Latch}
\begin{lstlisting}
module D_Latch (D, clock, Q, Qb);   
   input D, clock;
   output reg Q, Qb; // `reg` means it's an always block

   always@(D,clock) //defining a block that's sensitive to changes in Q and D.
   begin
      if(clock==1'b1)
      begin // need this begin because you're doing two things in the if block.
         Q = D1;
         Q = ~D;
      end // begin and end function like curly braces in C/C++/Java
   end //if clock == 0'b1, then verilog maintains previous values. 

endmodule
\end{lstlisting}

\subsection{Edge-Triggered Flip Flop}
\begin{lstlisting}
module D_ft(D, clock, Q, Qb)
   input D, clock;
   output reg Q, Qb;

   // Always blocks tell you what you need to 
   always@(posedge clock) // This means you execute this on the positive edge (posedge is a keyword for that)
   begin 
      Q <= D; // use '<=' for describing flip flops.
      Qb <= ~D; // we may get to why in this course but for now it's just a thing...
   end
endmodule
\end{lstlisting}

\subsection{Synchronous Reset (Active Low)}
\begin{lstlisting}
always@(popsedge clock)
begin
   if(resetn == 1'b0)
   begin
      Q <= 1'b0;
      Qb <= 1'b1;
   end
   else 
   begin
      Q <= D;
      Qb <= ~D;
   end
end 

endmodule;

\end{lstlisting}






\end{document}
